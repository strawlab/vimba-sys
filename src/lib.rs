/* automatically generated by rust-bindgen 0.60.1 */

#![allow(
    dead_code,
    non_upper_case_globals,
    non_camel_case_types,
    non_snake_case
)]

pub const VMBINFINITE: u32 = 4294967295;
pub type VmbInt8_t = ::std::os::raw::c_schar;
pub type VmbUint8_t = ::std::os::raw::c_uchar;
pub type VmbInt16_t = ::std::os::raw::c_short;
pub type VmbUint16_t = ::std::os::raw::c_ushort;
pub type VmbInt32_t = ::std::os::raw::c_int;
pub type VmbUint32_t = ::std::os::raw::c_uint;
pub type VmbInt64_t = ::std::os::raw::c_longlong;
pub type VmbUint64_t = ::std::os::raw::c_ulonglong;
pub type VmbHandle_t = *mut ::std::os::raw::c_void;
pub type VmbBool_t = ::std::os::raw::c_char;
pub mod VmbBoolVal {
    pub type Type = ::std::os::raw::c_uint;
    pub const VmbBoolTrue: Type = 1;
    pub const VmbBoolFalse: Type = 0;
}
pub type VmbUchar_t = ::std::os::raw::c_uchar;
pub mod VmbErrorType {
    pub type Type = ::std::os::raw::c_int;
    pub const VmbErrorSuccess: Type = 0;
    pub const VmbErrorInternalFault: Type = -1;
    pub const VmbErrorApiNotStarted: Type = -2;
    pub const VmbErrorNotFound: Type = -3;
    pub const VmbErrorBadHandle: Type = -4;
    pub const VmbErrorDeviceNotOpen: Type = -5;
    pub const VmbErrorInvalidAccess: Type = -6;
    pub const VmbErrorBadParameter: Type = -7;
    pub const VmbErrorStructSize: Type = -8;
    pub const VmbErrorMoreData: Type = -9;
    pub const VmbErrorWrongType: Type = -10;
    pub const VmbErrorInvalidValue: Type = -11;
    pub const VmbErrorTimeout: Type = -12;
    pub const VmbErrorOther: Type = -13;
    pub const VmbErrorResources: Type = -14;
    pub const VmbErrorInvalidCall: Type = -15;
    pub const VmbErrorNoTL: Type = -16;
    pub const VmbErrorNotImplemented: Type = -17;
    pub const VmbErrorNotSupported: Type = -18;
    pub const VmbErrorIncomplete: Type = -19;
    pub const VmbErrorIO: Type = -20;
}
pub type VmbError_t = VmbInt32_t;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct VmbVersionInfo_t {
    pub major: VmbUint32_t,
    pub minor: VmbUint32_t,
    pub patch: VmbUint32_t,
}
#[test]
fn bindgen_test_layout_VmbVersionInfo_t() {
    assert_eq!(
        ::std::mem::size_of::<VmbVersionInfo_t>(),
        12usize,
        concat!("Size of: ", stringify!(VmbVersionInfo_t))
    );
    assert_eq!(
        ::std::mem::align_of::<VmbVersionInfo_t>(),
        4usize,
        concat!("Alignment of ", stringify!(VmbVersionInfo_t))
    );
    fn test_field_major() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VmbVersionInfo_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).major) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VmbVersionInfo_t),
                "::",
                stringify!(major)
            )
        );
    }
    test_field_major();
    fn test_field_minor() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VmbVersionInfo_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).minor) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(VmbVersionInfo_t),
                "::",
                stringify!(minor)
            )
        );
    }
    test_field_minor();
    fn test_field_patch() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VmbVersionInfo_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).patch) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VmbVersionInfo_t),
                "::",
                stringify!(patch)
            )
        );
    }
    test_field_patch();
}
pub mod VmbPixelType {
    pub type Type = ::std::os::raw::c_uint;
    pub const VmbPixelMono: Type = 16777216;
    pub const VmbPixelColor: Type = 33554432;
}
pub mod VmbPixelOccupyType {
    pub type Type = ::std::os::raw::c_uint;
    pub const VmbPixelOccupy8Bit: Type = 524288;
    pub const VmbPixelOccupy10Bit: Type = 655360;
    pub const VmbPixelOccupy12Bit: Type = 786432;
    pub const VmbPixelOccupy14Bit: Type = 917504;
    pub const VmbPixelOccupy16Bit: Type = 1048576;
    pub const VmbPixelOccupy24Bit: Type = 1572864;
    pub const VmbPixelOccupy32Bit: Type = 2097152;
    pub const VmbPixelOccupy48Bit: Type = 3145728;
    pub const VmbPixelOccupy64Bit: Type = 4194304;
}
pub mod VmbPixelFormatType {
    pub type Type = ::std::os::raw::c_uint;
    pub const VmbPixelFormatMono8: Type = 17301505;
    pub const VmbPixelFormatMono10: Type = 17825795;
    pub const VmbPixelFormatMono10p: Type = 17432646;
    pub const VmbPixelFormatMono12: Type = 17825797;
    pub const VmbPixelFormatMono12Packed: Type = 17563654;
    pub const VmbPixelFormatMono12p: Type = 17563719;
    pub const VmbPixelFormatMono14: Type = 17825829;
    pub const VmbPixelFormatMono16: Type = 17825799;
    pub const VmbPixelFormatBayerGR8: Type = 17301512;
    pub const VmbPixelFormatBayerRG8: Type = 17301513;
    pub const VmbPixelFormatBayerGB8: Type = 17301514;
    pub const VmbPixelFormatBayerBG8: Type = 17301515;
    pub const VmbPixelFormatBayerGR10: Type = 17825804;
    pub const VmbPixelFormatBayerRG10: Type = 17825805;
    pub const VmbPixelFormatBayerGB10: Type = 17825806;
    pub const VmbPixelFormatBayerBG10: Type = 17825807;
    pub const VmbPixelFormatBayerGR12: Type = 17825808;
    pub const VmbPixelFormatBayerRG12: Type = 17825809;
    pub const VmbPixelFormatBayerGB12: Type = 17825810;
    pub const VmbPixelFormatBayerBG12: Type = 17825811;
    pub const VmbPixelFormatBayerGR12Packed: Type = 17563690;
    pub const VmbPixelFormatBayerRG12Packed: Type = 17563691;
    pub const VmbPixelFormatBayerGB12Packed: Type = 17563692;
    pub const VmbPixelFormatBayerBG12Packed: Type = 17563693;
    pub const VmbPixelFormatBayerGR10p: Type = 17432662;
    pub const VmbPixelFormatBayerRG10p: Type = 17432664;
    pub const VmbPixelFormatBayerGB10p: Type = 17432660;
    pub const VmbPixelFormatBayerBG10p: Type = 17432658;
    pub const VmbPixelFormatBayerGR12p: Type = 17563735;
    pub const VmbPixelFormatBayerRG12p: Type = 17563737;
    pub const VmbPixelFormatBayerGB12p: Type = 17563733;
    pub const VmbPixelFormatBayerBG12p: Type = 17563731;
    pub const VmbPixelFormatBayerGR16: Type = 17825838;
    pub const VmbPixelFormatBayerRG16: Type = 17825839;
    pub const VmbPixelFormatBayerGB16: Type = 17825840;
    pub const VmbPixelFormatBayerBG16: Type = 17825841;
    pub const VmbPixelFormatRgb8: Type = 35127316;
    pub const VmbPixelFormatBgr8: Type = 35127317;
    pub const VmbPixelFormatRgb10: Type = 36700184;
    pub const VmbPixelFormatBgr10: Type = 36700185;
    pub const VmbPixelFormatRgb12: Type = 36700186;
    pub const VmbPixelFormatBgr12: Type = 36700187;
    pub const VmbPixelFormatRgb14: Type = 36700254;
    pub const VmbPixelFormatBgr14: Type = 36700234;
    pub const VmbPixelFormatRgb16: Type = 36700211;
    pub const VmbPixelFormatBgr16: Type = 36700235;
    pub const VmbPixelFormatArgb8: Type = 35651606;
    pub const VmbPixelFormatRgba8: Type = 35651606;
    pub const VmbPixelFormatBgra8: Type = 35651607;
    pub const VmbPixelFormatRgba10: Type = 37748831;
    pub const VmbPixelFormatBgra10: Type = 37748812;
    pub const VmbPixelFormatRgba12: Type = 37748833;
    pub const VmbPixelFormatBgra12: Type = 37748814;
    pub const VmbPixelFormatRgba14: Type = 37748835;
    pub const VmbPixelFormatBgra14: Type = 37748816;
    pub const VmbPixelFormatRgba16: Type = 37748836;
    pub const VmbPixelFormatBgra16: Type = 37748817;
    pub const VmbPixelFormatYuv411: Type = 34340894;
    pub const VmbPixelFormatYuv422: Type = 34603039;
    pub const VmbPixelFormatYuv444: Type = 35127328;
    pub const VmbPixelFormatYCbCr411_8_CbYYCrYY: Type = 34340924;
    pub const VmbPixelFormatYCbCr422_8_CbYCrY: Type = 34603075;
    pub const VmbPixelFormatYCbCr8_CbYCr: Type = 35127354;
    pub const VmbPixelFormatLast: Type = 35127355;
}
pub type VmbPixelFormat_t = VmbUint32_t;
extern "C" {
    pub static gVimbaHandle: VmbHandle_t;
}
pub mod VmbInterfaceType {
    pub type Type = ::std::os::raw::c_uint;
    pub const VmbInterfaceUnknown: Type = 0;
    pub const VmbInterfaceFirewire: Type = 1;
    pub const VmbInterfaceEthernet: Type = 2;
    pub const VmbInterfaceUsb: Type = 3;
    pub const VmbInterfaceCL: Type = 4;
    pub const VmbInterfaceCSI2: Type = 5;
}
pub type VmbInterface_t = VmbUint32_t;
pub mod VmbAccessModeType {
    pub type Type = ::std::os::raw::c_uint;
    pub const VmbAccessModeNone: Type = 0;
    pub const VmbAccessModeFull: Type = 1;
    pub const VmbAccessModeRead: Type = 2;
    pub const VmbAccessModeConfig: Type = 4;
    pub const VmbAccessModeLite: Type = 8;
}
pub type VmbAccessMode_t = VmbUint32_t;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct VmbInterfaceInfo_t {
    pub interfaceIdString: *const ::std::os::raw::c_char,
    pub interfaceType: VmbInterface_t,
    pub interfaceName: *const ::std::os::raw::c_char,
    pub serialString: *const ::std::os::raw::c_char,
    pub permittedAccess: VmbAccessMode_t,
}
#[test]
fn bindgen_test_layout_VmbInterfaceInfo_t() {
    assert_eq!(
        ::std::mem::size_of::<VmbInterfaceInfo_t>(),
        40usize,
        concat!("Size of: ", stringify!(VmbInterfaceInfo_t))
    );
    assert_eq!(
        ::std::mem::align_of::<VmbInterfaceInfo_t>(),
        8usize,
        concat!("Alignment of ", stringify!(VmbInterfaceInfo_t))
    );
    fn test_field_interfaceIdString() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VmbInterfaceInfo_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).interfaceIdString) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VmbInterfaceInfo_t),
                "::",
                stringify!(interfaceIdString)
            )
        );
    }
    test_field_interfaceIdString();
    fn test_field_interfaceType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VmbInterfaceInfo_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).interfaceType) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VmbInterfaceInfo_t),
                "::",
                stringify!(interfaceType)
            )
        );
    }
    test_field_interfaceType();
    fn test_field_interfaceName() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VmbInterfaceInfo_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).interfaceName) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VmbInterfaceInfo_t),
                "::",
                stringify!(interfaceName)
            )
        );
    }
    test_field_interfaceName();
    fn test_field_serialString() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VmbInterfaceInfo_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).serialString) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(VmbInterfaceInfo_t),
                "::",
                stringify!(serialString)
            )
        );
    }
    test_field_serialString();
    fn test_field_permittedAccess() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VmbInterfaceInfo_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).permittedAccess) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(VmbInterfaceInfo_t),
                "::",
                stringify!(permittedAccess)
            )
        );
    }
    test_field_permittedAccess();
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct VmbCameraInfo_t {
    pub cameraIdString: *const ::std::os::raw::c_char,
    pub cameraName: *const ::std::os::raw::c_char,
    pub modelName: *const ::std::os::raw::c_char,
    pub serialString: *const ::std::os::raw::c_char,
    pub permittedAccess: VmbAccessMode_t,
    pub interfaceIdString: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_VmbCameraInfo_t() {
    assert_eq!(
        ::std::mem::size_of::<VmbCameraInfo_t>(),
        48usize,
        concat!("Size of: ", stringify!(VmbCameraInfo_t))
    );
    assert_eq!(
        ::std::mem::align_of::<VmbCameraInfo_t>(),
        8usize,
        concat!("Alignment of ", stringify!(VmbCameraInfo_t))
    );
    fn test_field_cameraIdString() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VmbCameraInfo_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).cameraIdString) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VmbCameraInfo_t),
                "::",
                stringify!(cameraIdString)
            )
        );
    }
    test_field_cameraIdString();
    fn test_field_cameraName() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VmbCameraInfo_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).cameraName) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VmbCameraInfo_t),
                "::",
                stringify!(cameraName)
            )
        );
    }
    test_field_cameraName();
    fn test_field_modelName() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VmbCameraInfo_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).modelName) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VmbCameraInfo_t),
                "::",
                stringify!(modelName)
            )
        );
    }
    test_field_modelName();
    fn test_field_serialString() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VmbCameraInfo_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).serialString) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(VmbCameraInfo_t),
                "::",
                stringify!(serialString)
            )
        );
    }
    test_field_serialString();
    fn test_field_permittedAccess() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VmbCameraInfo_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).permittedAccess) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(VmbCameraInfo_t),
                "::",
                stringify!(permittedAccess)
            )
        );
    }
    test_field_permittedAccess();
    fn test_field_interfaceIdString() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VmbCameraInfo_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).interfaceIdString) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(VmbCameraInfo_t),
                "::",
                stringify!(interfaceIdString)
            )
        );
    }
    test_field_interfaceIdString();
}
pub mod VmbFeatureDataType {
    pub type Type = ::std::os::raw::c_uint;
    pub const VmbFeatureDataUnknown: Type = 0;
    pub const VmbFeatureDataInt: Type = 1;
    pub const VmbFeatureDataFloat: Type = 2;
    pub const VmbFeatureDataEnum: Type = 3;
    pub const VmbFeatureDataString: Type = 4;
    pub const VmbFeatureDataBool: Type = 5;
    pub const VmbFeatureDataCommand: Type = 6;
    pub const VmbFeatureDataRaw: Type = 7;
    pub const VmbFeatureDataNone: Type = 8;
}
pub type VmbFeatureData_t = VmbUint32_t;
pub mod VmbFeatureVisibilityType {
    pub type Type = ::std::os::raw::c_uint;
    pub const VmbFeatureVisibilityUnknown: Type = 0;
    pub const VmbFeatureVisibilityBeginner: Type = 1;
    pub const VmbFeatureVisibilityExpert: Type = 2;
    pub const VmbFeatureVisibilityGuru: Type = 3;
    pub const VmbFeatureVisibilityInvisible: Type = 4;
}
pub type VmbFeatureVisibility_t = VmbUint32_t;
impl VmbFeatureFlagsType {
    pub const VmbFeatureFlagsNone: VmbFeatureFlagsType = VmbFeatureFlagsType(0);
}
impl VmbFeatureFlagsType {
    pub const VmbFeatureFlagsRead: VmbFeatureFlagsType = VmbFeatureFlagsType(1);
}
impl VmbFeatureFlagsType {
    pub const VmbFeatureFlagsWrite: VmbFeatureFlagsType = VmbFeatureFlagsType(2);
}
impl VmbFeatureFlagsType {
    pub const VmbFeatureFlagsVolatile: VmbFeatureFlagsType = VmbFeatureFlagsType(8);
}
impl VmbFeatureFlagsType {
    pub const VmbFeatureFlagsModifyWrite: VmbFeatureFlagsType = VmbFeatureFlagsType(16);
}
impl ::std::ops::BitOr<VmbFeatureFlagsType> for VmbFeatureFlagsType {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        VmbFeatureFlagsType(self.0 | other.0)
    }
}
impl ::std::ops::BitOrAssign for VmbFeatureFlagsType {
    #[inline]
    fn bitor_assign(&mut self, rhs: VmbFeatureFlagsType) {
        self.0 |= rhs.0;
    }
}
impl ::std::ops::BitAnd<VmbFeatureFlagsType> for VmbFeatureFlagsType {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        VmbFeatureFlagsType(self.0 & other.0)
    }
}
impl ::std::ops::BitAndAssign for VmbFeatureFlagsType {
    #[inline]
    fn bitand_assign(&mut self, rhs: VmbFeatureFlagsType) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct VmbFeatureFlagsType(pub ::std::os::raw::c_uint);
pub type VmbFeatureFlags_t = VmbUint32_t;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct VmbFeatureInfo {
    pub name: *const ::std::os::raw::c_char,
    pub featureDataType: VmbFeatureData_t,
    pub featureFlags: VmbFeatureFlags_t,
    pub category: *const ::std::os::raw::c_char,
    pub displayName: *const ::std::os::raw::c_char,
    pub pollingTime: VmbUint32_t,
    pub unit: *const ::std::os::raw::c_char,
    pub representation: *const ::std::os::raw::c_char,
    pub visibility: VmbFeatureVisibility_t,
    pub tooltip: *const ::std::os::raw::c_char,
    pub description: *const ::std::os::raw::c_char,
    pub sfncNamespace: *const ::std::os::raw::c_char,
    pub isStreamable: VmbBool_t,
    pub hasAffectedFeatures: VmbBool_t,
    pub hasSelectedFeatures: VmbBool_t,
}
#[test]
fn bindgen_test_layout_VmbFeatureInfo() {
    assert_eq!(
        ::std::mem::size_of::<VmbFeatureInfo>(),
        96usize,
        concat!("Size of: ", stringify!(VmbFeatureInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<VmbFeatureInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(VmbFeatureInfo))
    );
    fn test_field_name() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VmbFeatureInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VmbFeatureInfo),
                "::",
                stringify!(name)
            )
        );
    }
    test_field_name();
    fn test_field_featureDataType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VmbFeatureInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).featureDataType) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VmbFeatureInfo),
                "::",
                stringify!(featureDataType)
            )
        );
    }
    test_field_featureDataType();
    fn test_field_featureFlags() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VmbFeatureInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).featureFlags) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(VmbFeatureInfo),
                "::",
                stringify!(featureFlags)
            )
        );
    }
    test_field_featureFlags();
    fn test_field_category() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VmbFeatureInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).category) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VmbFeatureInfo),
                "::",
                stringify!(category)
            )
        );
    }
    test_field_category();
    fn test_field_displayName() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VmbFeatureInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).displayName) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(VmbFeatureInfo),
                "::",
                stringify!(displayName)
            )
        );
    }
    test_field_displayName();
    fn test_field_pollingTime() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VmbFeatureInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pollingTime) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(VmbFeatureInfo),
                "::",
                stringify!(pollingTime)
            )
        );
    }
    test_field_pollingTime();
    fn test_field_unit() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VmbFeatureInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).unit) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(VmbFeatureInfo),
                "::",
                stringify!(unit)
            )
        );
    }
    test_field_unit();
    fn test_field_representation() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VmbFeatureInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).representation) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(VmbFeatureInfo),
                "::",
                stringify!(representation)
            )
        );
    }
    test_field_representation();
    fn test_field_visibility() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VmbFeatureInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).visibility) as usize - ptr as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(VmbFeatureInfo),
                "::",
                stringify!(visibility)
            )
        );
    }
    test_field_visibility();
    fn test_field_tooltip() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VmbFeatureInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).tooltip) as usize - ptr as usize
            },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(VmbFeatureInfo),
                "::",
                stringify!(tooltip)
            )
        );
    }
    test_field_tooltip();
    fn test_field_description() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VmbFeatureInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).description) as usize - ptr as usize
            },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(VmbFeatureInfo),
                "::",
                stringify!(description)
            )
        );
    }
    test_field_description();
    fn test_field_sfncNamespace() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VmbFeatureInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sfncNamespace) as usize - ptr as usize
            },
            80usize,
            concat!(
                "Offset of field: ",
                stringify!(VmbFeatureInfo),
                "::",
                stringify!(sfncNamespace)
            )
        );
    }
    test_field_sfncNamespace();
    fn test_field_isStreamable() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VmbFeatureInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).isStreamable) as usize - ptr as usize
            },
            88usize,
            concat!(
                "Offset of field: ",
                stringify!(VmbFeatureInfo),
                "::",
                stringify!(isStreamable)
            )
        );
    }
    test_field_isStreamable();
    fn test_field_hasAffectedFeatures() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VmbFeatureInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).hasAffectedFeatures) as usize - ptr as usize
            },
            89usize,
            concat!(
                "Offset of field: ",
                stringify!(VmbFeatureInfo),
                "::",
                stringify!(hasAffectedFeatures)
            )
        );
    }
    test_field_hasAffectedFeatures();
    fn test_field_hasSelectedFeatures() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VmbFeatureInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).hasSelectedFeatures) as usize - ptr as usize
            },
            90usize,
            concat!(
                "Offset of field: ",
                stringify!(VmbFeatureInfo),
                "::",
                stringify!(hasSelectedFeatures)
            )
        );
    }
    test_field_hasSelectedFeatures();
}
pub type VmbFeatureInfo_t = VmbFeatureInfo;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct VmbFeatureEnumEntry {
    pub name: *const ::std::os::raw::c_char,
    pub displayName: *const ::std::os::raw::c_char,
    pub visibility: VmbFeatureVisibility_t,
    pub tooltip: *const ::std::os::raw::c_char,
    pub description: *const ::std::os::raw::c_char,
    pub sfncNamespace: *const ::std::os::raw::c_char,
    pub intValue: VmbInt64_t,
}
#[test]
fn bindgen_test_layout_VmbFeatureEnumEntry() {
    assert_eq!(
        ::std::mem::size_of::<VmbFeatureEnumEntry>(),
        56usize,
        concat!("Size of: ", stringify!(VmbFeatureEnumEntry))
    );
    assert_eq!(
        ::std::mem::align_of::<VmbFeatureEnumEntry>(),
        8usize,
        concat!("Alignment of ", stringify!(VmbFeatureEnumEntry))
    );
    fn test_field_name() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VmbFeatureEnumEntry>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VmbFeatureEnumEntry),
                "::",
                stringify!(name)
            )
        );
    }
    test_field_name();
    fn test_field_displayName() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VmbFeatureEnumEntry>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).displayName) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VmbFeatureEnumEntry),
                "::",
                stringify!(displayName)
            )
        );
    }
    test_field_displayName();
    fn test_field_visibility() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VmbFeatureEnumEntry>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).visibility) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VmbFeatureEnumEntry),
                "::",
                stringify!(visibility)
            )
        );
    }
    test_field_visibility();
    fn test_field_tooltip() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VmbFeatureEnumEntry>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).tooltip) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(VmbFeatureEnumEntry),
                "::",
                stringify!(tooltip)
            )
        );
    }
    test_field_tooltip();
    fn test_field_description() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VmbFeatureEnumEntry>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).description) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(VmbFeatureEnumEntry),
                "::",
                stringify!(description)
            )
        );
    }
    test_field_description();
    fn test_field_sfncNamespace() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VmbFeatureEnumEntry>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sfncNamespace) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(VmbFeatureEnumEntry),
                "::",
                stringify!(sfncNamespace)
            )
        );
    }
    test_field_sfncNamespace();
    fn test_field_intValue() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VmbFeatureEnumEntry>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).intValue) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(VmbFeatureEnumEntry),
                "::",
                stringify!(intValue)
            )
        );
    }
    test_field_intValue();
}
pub type VmbFeatureEnumEntry_t = VmbFeatureEnumEntry;
pub mod VmbFrameStatusType {
    pub type Type = ::std::os::raw::c_int;
    pub const VmbFrameStatusComplete: Type = 0;
    pub const VmbFrameStatusIncomplete: Type = -1;
    pub const VmbFrameStatusTooSmall: Type = -2;
    pub const VmbFrameStatusInvalid: Type = -3;
}
pub type VmbFrameStatus_t = VmbInt32_t;
impl VmbFrameFlagsType {
    pub const VmbFrameFlagsNone: VmbFrameFlagsType = VmbFrameFlagsType(0);
}
impl VmbFrameFlagsType {
    pub const VmbFrameFlagsDimension: VmbFrameFlagsType = VmbFrameFlagsType(1);
}
impl VmbFrameFlagsType {
    pub const VmbFrameFlagsOffset: VmbFrameFlagsType = VmbFrameFlagsType(2);
}
impl VmbFrameFlagsType {
    pub const VmbFrameFlagsFrameID: VmbFrameFlagsType = VmbFrameFlagsType(4);
}
impl VmbFrameFlagsType {
    pub const VmbFrameFlagsTimestamp: VmbFrameFlagsType = VmbFrameFlagsType(8);
}
impl ::std::ops::BitOr<VmbFrameFlagsType> for VmbFrameFlagsType {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        VmbFrameFlagsType(self.0 | other.0)
    }
}
impl ::std::ops::BitOrAssign for VmbFrameFlagsType {
    #[inline]
    fn bitor_assign(&mut self, rhs: VmbFrameFlagsType) {
        self.0 |= rhs.0;
    }
}
impl ::std::ops::BitAnd<VmbFrameFlagsType> for VmbFrameFlagsType {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        VmbFrameFlagsType(self.0 & other.0)
    }
}
impl ::std::ops::BitAndAssign for VmbFrameFlagsType {
    #[inline]
    fn bitand_assign(&mut self, rhs: VmbFrameFlagsType) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct VmbFrameFlagsType(pub ::std::os::raw::c_uint);
pub type VmbFrameFlags_t = VmbUint32_t;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct VmbFrame_t {
    pub buffer: *mut ::std::os::raw::c_void,
    pub bufferSize: VmbUint32_t,
    pub context: [*mut ::std::os::raw::c_void; 4usize],
    pub receiveStatus: VmbFrameStatus_t,
    pub receiveFlags: VmbFrameFlags_t,
    pub imageSize: VmbUint32_t,
    pub ancillarySize: VmbUint32_t,
    pub pixelFormat: VmbPixelFormat_t,
    pub width: VmbUint32_t,
    pub height: VmbUint32_t,
    pub offsetX: VmbUint32_t,
    pub offsetY: VmbUint32_t,
    pub frameID: VmbUint64_t,
    pub timestamp: VmbUint64_t,
}
#[test]
fn bindgen_test_layout_VmbFrame_t() {
    assert_eq!(
        ::std::mem::size_of::<VmbFrame_t>(),
        104usize,
        concat!("Size of: ", stringify!(VmbFrame_t))
    );
    assert_eq!(
        ::std::mem::align_of::<VmbFrame_t>(),
        8usize,
        concat!("Alignment of ", stringify!(VmbFrame_t))
    );
    fn test_field_buffer() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VmbFrame_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).buffer) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VmbFrame_t),
                "::",
                stringify!(buffer)
            )
        );
    }
    test_field_buffer();
    fn test_field_bufferSize() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VmbFrame_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).bufferSize) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VmbFrame_t),
                "::",
                stringify!(bufferSize)
            )
        );
    }
    test_field_bufferSize();
    fn test_field_context() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VmbFrame_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).context) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VmbFrame_t),
                "::",
                stringify!(context)
            )
        );
    }
    test_field_context();
    fn test_field_receiveStatus() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VmbFrame_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).receiveStatus) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(VmbFrame_t),
                "::",
                stringify!(receiveStatus)
            )
        );
    }
    test_field_receiveStatus();
    fn test_field_receiveFlags() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VmbFrame_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).receiveFlags) as usize - ptr as usize
            },
            52usize,
            concat!(
                "Offset of field: ",
                stringify!(VmbFrame_t),
                "::",
                stringify!(receiveFlags)
            )
        );
    }
    test_field_receiveFlags();
    fn test_field_imageSize() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VmbFrame_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).imageSize) as usize - ptr as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(VmbFrame_t),
                "::",
                stringify!(imageSize)
            )
        );
    }
    test_field_imageSize();
    fn test_field_ancillarySize() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VmbFrame_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ancillarySize) as usize - ptr as usize
            },
            60usize,
            concat!(
                "Offset of field: ",
                stringify!(VmbFrame_t),
                "::",
                stringify!(ancillarySize)
            )
        );
    }
    test_field_ancillarySize();
    fn test_field_pixelFormat() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VmbFrame_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pixelFormat) as usize - ptr as usize
            },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(VmbFrame_t),
                "::",
                stringify!(pixelFormat)
            )
        );
    }
    test_field_pixelFormat();
    fn test_field_width() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VmbFrame_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).width) as usize - ptr as usize
            },
            68usize,
            concat!(
                "Offset of field: ",
                stringify!(VmbFrame_t),
                "::",
                stringify!(width)
            )
        );
    }
    test_field_width();
    fn test_field_height() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VmbFrame_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).height) as usize - ptr as usize
            },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(VmbFrame_t),
                "::",
                stringify!(height)
            )
        );
    }
    test_field_height();
    fn test_field_offsetX() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VmbFrame_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).offsetX) as usize - ptr as usize
            },
            76usize,
            concat!(
                "Offset of field: ",
                stringify!(VmbFrame_t),
                "::",
                stringify!(offsetX)
            )
        );
    }
    test_field_offsetX();
    fn test_field_offsetY() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VmbFrame_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).offsetY) as usize - ptr as usize
            },
            80usize,
            concat!(
                "Offset of field: ",
                stringify!(VmbFrame_t),
                "::",
                stringify!(offsetY)
            )
        );
    }
    test_field_offsetY();
    fn test_field_frameID() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VmbFrame_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).frameID) as usize - ptr as usize
            },
            88usize,
            concat!(
                "Offset of field: ",
                stringify!(VmbFrame_t),
                "::",
                stringify!(frameID)
            )
        );
    }
    test_field_frameID();
    fn test_field_timestamp() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VmbFrame_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).timestamp) as usize - ptr as usize
            },
            96usize,
            concat!(
                "Offset of field: ",
                stringify!(VmbFrame_t),
                "::",
                stringify!(timestamp)
            )
        );
    }
    test_field_timestamp();
}
pub mod VmbFeaturePersistType {
    pub type Type = ::std::os::raw::c_uint;
    pub const VmbFeaturePersistAll: Type = 0;
    pub const VmbFeaturePersistStreamable: Type = 1;
    pub const VmbFeaturePersistNoLUT: Type = 2;
}
pub type VmbFeaturePersist_t = VmbUint32_t;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct VmbFeaturePersistSettings_t {
    pub persistType: VmbFeaturePersist_t,
    pub maxIterations: VmbUint32_t,
    pub loggingLevel: VmbUint32_t,
}
#[test]
fn bindgen_test_layout_VmbFeaturePersistSettings_t() {
    assert_eq!(
        ::std::mem::size_of::<VmbFeaturePersistSettings_t>(),
        12usize,
        concat!("Size of: ", stringify!(VmbFeaturePersistSettings_t))
    );
    assert_eq!(
        ::std::mem::align_of::<VmbFeaturePersistSettings_t>(),
        4usize,
        concat!("Alignment of ", stringify!(VmbFeaturePersistSettings_t))
    );
    fn test_field_persistType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VmbFeaturePersistSettings_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).persistType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VmbFeaturePersistSettings_t),
                "::",
                stringify!(persistType)
            )
        );
    }
    test_field_persistType();
    fn test_field_maxIterations() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VmbFeaturePersistSettings_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxIterations) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(VmbFeaturePersistSettings_t),
                "::",
                stringify!(maxIterations)
            )
        );
    }
    test_field_maxIterations();
    fn test_field_loggingLevel() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VmbFeaturePersistSettings_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).loggingLevel) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VmbFeaturePersistSettings_t),
                "::",
                stringify!(loggingLevel)
            )
        );
    }
    test_field_loggingLevel();
}
pub type VmbInvalidationCallback = ::std::option::Option<
    unsafe extern "C" fn(
        handle: VmbHandle_t,
        name: *const ::std::os::raw::c_char,
        pUserContext: *mut ::std::os::raw::c_void,
    ),
>;
pub type VmbFrameCallback =
    ::std::option::Option<unsafe extern "C" fn(cameraHandle: VmbHandle_t, pFrame: *mut VmbFrame_t)>;
extern crate libloading;
pub struct VimbaC {
    __library: ::libloading::Library,
    pub VmbVersionQuery: Result<
        unsafe extern "C" fn(
            pVersionInfo: *mut VmbVersionInfo_t,
            sizeofVersionInfo: VmbUint32_t,
        ) -> VmbError_t,
        ::libloading::Error,
    >,
    pub VmbStartup: Result<unsafe extern "C" fn() -> VmbError_t, ::libloading::Error>,
    pub VmbShutdown: Result<unsafe extern "C" fn(), ::libloading::Error>,
    pub VmbCamerasList: Result<
        unsafe extern "C" fn(
            pCameraInfo: *mut VmbCameraInfo_t,
            listLength: VmbUint32_t,
            pNumFound: *mut VmbUint32_t,
            sizeofCameraInfo: VmbUint32_t,
        ) -> VmbError_t,
        ::libloading::Error,
    >,
    pub VmbCameraInfoQuery: Result<
        unsafe extern "C" fn(
            idString: *const ::std::os::raw::c_char,
            pInfo: *mut VmbCameraInfo_t,
            sizeofCameraInfo: VmbUint32_t,
        ) -> VmbError_t,
        ::libloading::Error,
    >,
    pub VmbCameraOpen: Result<
        unsafe extern "C" fn(
            idString: *const ::std::os::raw::c_char,
            accessMode: VmbAccessMode_t,
            pCameraHandle: *mut VmbHandle_t,
        ) -> VmbError_t,
        ::libloading::Error,
    >,
    pub VmbCameraClose:
        Result<unsafe extern "C" fn(cameraHandle: VmbHandle_t) -> VmbError_t, ::libloading::Error>,
    pub VmbFeaturesList: Result<
        unsafe extern "C" fn(
            handle: VmbHandle_t,
            pFeatureInfoList: *mut VmbFeatureInfo_t,
            listLength: VmbUint32_t,
            pNumFound: *mut VmbUint32_t,
            sizeofFeatureInfo: VmbUint32_t,
        ) -> VmbError_t,
        ::libloading::Error,
    >,
    pub VmbFeatureInfoQuery: Result<
        unsafe extern "C" fn(
            handle: VmbHandle_t,
            name: *const ::std::os::raw::c_char,
            pFeatureInfo: *mut VmbFeatureInfo_t,
            sizeofFeatureInfo: VmbUint32_t,
        ) -> VmbError_t,
        ::libloading::Error,
    >,
    pub VmbFeatureListAffected: Result<
        unsafe extern "C" fn(
            handle: VmbHandle_t,
            name: *const ::std::os::raw::c_char,
            pFeatureInfoList: *mut VmbFeatureInfo_t,
            listLength: VmbUint32_t,
            pNumFound: *mut VmbUint32_t,
            sizeofFeatureInfo: VmbUint32_t,
        ) -> VmbError_t,
        ::libloading::Error,
    >,
    pub VmbFeatureListSelected: Result<
        unsafe extern "C" fn(
            handle: VmbHandle_t,
            name: *const ::std::os::raw::c_char,
            pFeatureInfoList: *mut VmbFeatureInfo_t,
            listLength: VmbUint32_t,
            pNumFound: *mut VmbUint32_t,
            sizeofFeatureInfo: VmbUint32_t,
        ) -> VmbError_t,
        ::libloading::Error,
    >,
    pub VmbFeatureAccessQuery: Result<
        unsafe extern "C" fn(
            handle: VmbHandle_t,
            name: *const ::std::os::raw::c_char,
            pIsReadable: *mut VmbBool_t,
            pIsWriteable: *mut VmbBool_t,
        ) -> VmbError_t,
        ::libloading::Error,
    >,
    pub VmbFeatureIntGet: Result<
        unsafe extern "C" fn(
            handle: VmbHandle_t,
            name: *const ::std::os::raw::c_char,
            pValue: *mut VmbInt64_t,
        ) -> VmbError_t,
        ::libloading::Error,
    >,
    pub VmbFeatureIntSet: Result<
        unsafe extern "C" fn(
            handle: VmbHandle_t,
            name: *const ::std::os::raw::c_char,
            value: VmbInt64_t,
        ) -> VmbError_t,
        ::libloading::Error,
    >,
    pub VmbFeatureIntRangeQuery: Result<
        unsafe extern "C" fn(
            handle: VmbHandle_t,
            name: *const ::std::os::raw::c_char,
            pMin: *mut VmbInt64_t,
            pMax: *mut VmbInt64_t,
        ) -> VmbError_t,
        ::libloading::Error,
    >,
    pub VmbFeatureIntIncrementQuery: Result<
        unsafe extern "C" fn(
            handle: VmbHandle_t,
            name: *const ::std::os::raw::c_char,
            pValue: *mut VmbInt64_t,
        ) -> VmbError_t,
        ::libloading::Error,
    >,
    pub VmbFeatureFloatGet: Result<
        unsafe extern "C" fn(
            handle: VmbHandle_t,
            name: *const ::std::os::raw::c_char,
            pValue: *mut f64,
        ) -> VmbError_t,
        ::libloading::Error,
    >,
    pub VmbFeatureFloatSet: Result<
        unsafe extern "C" fn(
            handle: VmbHandle_t,
            name: *const ::std::os::raw::c_char,
            value: f64,
        ) -> VmbError_t,
        ::libloading::Error,
    >,
    pub VmbFeatureFloatRangeQuery: Result<
        unsafe extern "C" fn(
            handle: VmbHandle_t,
            name: *const ::std::os::raw::c_char,
            pMin: *mut f64,
            pMax: *mut f64,
        ) -> VmbError_t,
        ::libloading::Error,
    >,
    pub VmbFeatureFloatIncrementQuery: Result<
        unsafe extern "C" fn(
            handle: VmbHandle_t,
            name: *const ::std::os::raw::c_char,
            pHasIncrement: *mut VmbBool_t,
            pValue: *mut f64,
        ) -> VmbError_t,
        ::libloading::Error,
    >,
    pub VmbFeatureEnumGet: Result<
        unsafe extern "C" fn(
            handle: VmbHandle_t,
            name: *const ::std::os::raw::c_char,
            pValue: *mut *const ::std::os::raw::c_char,
        ) -> VmbError_t,
        ::libloading::Error,
    >,
    pub VmbFeatureEnumSet: Result<
        unsafe extern "C" fn(
            handle: VmbHandle_t,
            name: *const ::std::os::raw::c_char,
            value: *const ::std::os::raw::c_char,
        ) -> VmbError_t,
        ::libloading::Error,
    >,
    pub VmbFeatureEnumRangeQuery: Result<
        unsafe extern "C" fn(
            handle: VmbHandle_t,
            name: *const ::std::os::raw::c_char,
            pNameArray: *mut *const ::std::os::raw::c_char,
            arrayLength: VmbUint32_t,
            pNumFilled: *mut VmbUint32_t,
        ) -> VmbError_t,
        ::libloading::Error,
    >,
    pub VmbFeatureEnumIsAvailable: Result<
        unsafe extern "C" fn(
            handle: VmbHandle_t,
            name: *const ::std::os::raw::c_char,
            value: *const ::std::os::raw::c_char,
            pIsAvailable: *mut VmbBool_t,
        ) -> VmbError_t,
        ::libloading::Error,
    >,
    pub VmbFeatureEnumAsInt: Result<
        unsafe extern "C" fn(
            handle: VmbHandle_t,
            name: *const ::std::os::raw::c_char,
            value: *const ::std::os::raw::c_char,
            pIntVal: *mut VmbInt64_t,
        ) -> VmbError_t,
        ::libloading::Error,
    >,
    pub VmbFeatureEnumAsString: Result<
        unsafe extern "C" fn(
            handle: VmbHandle_t,
            name: *const ::std::os::raw::c_char,
            intValue: VmbInt64_t,
            pStringValue: *mut *const ::std::os::raw::c_char,
        ) -> VmbError_t,
        ::libloading::Error,
    >,
    pub VmbFeatureEnumEntryGet: Result<
        unsafe extern "C" fn(
            handle: VmbHandle_t,
            featureName: *const ::std::os::raw::c_char,
            entryName: *const ::std::os::raw::c_char,
            pFeatureEnumEntry: *mut VmbFeatureEnumEntry_t,
            sizeofFeatureEnumEntry: VmbUint32_t,
        ) -> VmbError_t,
        ::libloading::Error,
    >,
    pub VmbFeatureStringGet: Result<
        unsafe extern "C" fn(
            handle: VmbHandle_t,
            name: *const ::std::os::raw::c_char,
            buffer: *mut ::std::os::raw::c_char,
            bufferSize: VmbUint32_t,
            pSizeFilled: *mut VmbUint32_t,
        ) -> VmbError_t,
        ::libloading::Error,
    >,
    pub VmbFeatureStringSet: Result<
        unsafe extern "C" fn(
            handle: VmbHandle_t,
            name: *const ::std::os::raw::c_char,
            value: *const ::std::os::raw::c_char,
        ) -> VmbError_t,
        ::libloading::Error,
    >,
    pub VmbFeatureStringMaxlengthQuery: Result<
        unsafe extern "C" fn(
            handle: VmbHandle_t,
            name: *const ::std::os::raw::c_char,
            pMaxLength: *mut VmbUint32_t,
        ) -> VmbError_t,
        ::libloading::Error,
    >,
    pub VmbFeatureBoolGet: Result<
        unsafe extern "C" fn(
            handle: VmbHandle_t,
            name: *const ::std::os::raw::c_char,
            pValue: *mut VmbBool_t,
        ) -> VmbError_t,
        ::libloading::Error,
    >,
    pub VmbFeatureBoolSet: Result<
        unsafe extern "C" fn(
            handle: VmbHandle_t,
            name: *const ::std::os::raw::c_char,
            value: VmbBool_t,
        ) -> VmbError_t,
        ::libloading::Error,
    >,
    pub VmbFeatureCommandRun: Result<
        unsafe extern "C" fn(
            handle: VmbHandle_t,
            name: *const ::std::os::raw::c_char,
        ) -> VmbError_t,
        ::libloading::Error,
    >,
    pub VmbFeatureCommandIsDone: Result<
        unsafe extern "C" fn(
            handle: VmbHandle_t,
            name: *const ::std::os::raw::c_char,
            pIsDone: *mut VmbBool_t,
        ) -> VmbError_t,
        ::libloading::Error,
    >,
    pub VmbFeatureRawGet: Result<
        unsafe extern "C" fn(
            handle: VmbHandle_t,
            name: *const ::std::os::raw::c_char,
            pBuffer: *mut ::std::os::raw::c_char,
            bufferSize: VmbUint32_t,
            pSizeFilled: *mut VmbUint32_t,
        ) -> VmbError_t,
        ::libloading::Error,
    >,
    pub VmbFeatureRawSet: Result<
        unsafe extern "C" fn(
            handle: VmbHandle_t,
            name: *const ::std::os::raw::c_char,
            pBuffer: *const ::std::os::raw::c_char,
            bufferSize: VmbUint32_t,
        ) -> VmbError_t,
        ::libloading::Error,
    >,
    pub VmbFeatureRawLengthQuery: Result<
        unsafe extern "C" fn(
            handle: VmbHandle_t,
            name: *const ::std::os::raw::c_char,
            pLength: *mut VmbUint32_t,
        ) -> VmbError_t,
        ::libloading::Error,
    >,
    pub VmbFeatureInvalidationRegister: Result<
        unsafe extern "C" fn(
            handle: VmbHandle_t,
            name: *const ::std::os::raw::c_char,
            callback: VmbInvalidationCallback,
            pUserContext: *mut ::std::os::raw::c_void,
        ) -> VmbError_t,
        ::libloading::Error,
    >,
    pub VmbFeatureInvalidationUnregister: Result<
        unsafe extern "C" fn(
            handle: VmbHandle_t,
            name: *const ::std::os::raw::c_char,
            callback: VmbInvalidationCallback,
        ) -> VmbError_t,
        ::libloading::Error,
    >,
    pub VmbFrameAnnounce: Result<
        unsafe extern "C" fn(
            cameraHandle: VmbHandle_t,
            pFrame: *const VmbFrame_t,
            sizeofFrame: VmbUint32_t,
        ) -> VmbError_t,
        ::libloading::Error,
    >,
    pub VmbFrameRevoke: Result<
        unsafe extern "C" fn(cameraHandle: VmbHandle_t, pFrame: *const VmbFrame_t) -> VmbError_t,
        ::libloading::Error,
    >,
    pub VmbFrameRevokeAll:
        Result<unsafe extern "C" fn(cameraHandle: VmbHandle_t) -> VmbError_t, ::libloading::Error>,
    pub VmbCaptureStart:
        Result<unsafe extern "C" fn(cameraHandle: VmbHandle_t) -> VmbError_t, ::libloading::Error>,
    pub VmbCaptureEnd:
        Result<unsafe extern "C" fn(cameraHandle: VmbHandle_t) -> VmbError_t, ::libloading::Error>,
    pub VmbCaptureFrameQueue: Result<
        unsafe extern "C" fn(
            cameraHandle: VmbHandle_t,
            pFrame: *const VmbFrame_t,
            callback: VmbFrameCallback,
        ) -> VmbError_t,
        ::libloading::Error,
    >,
    pub VmbCaptureFrameWait: Result<
        unsafe extern "C" fn(
            cameraHandle: VmbHandle_t,
            pFrame: *const VmbFrame_t,
            timeout: VmbUint32_t,
        ) -> VmbError_t,
        ::libloading::Error,
    >,
    pub VmbCaptureQueueFlush:
        Result<unsafe extern "C" fn(cameraHandle: VmbHandle_t) -> VmbError_t, ::libloading::Error>,
    pub VmbInterfacesList: Result<
        unsafe extern "C" fn(
            pInterfaceInfo: *mut VmbInterfaceInfo_t,
            listLength: VmbUint32_t,
            pNumFound: *mut VmbUint32_t,
            sizeofInterfaceInfo: VmbUint32_t,
        ) -> VmbError_t,
        ::libloading::Error,
    >,
    pub VmbInterfaceOpen: Result<
        unsafe extern "C" fn(
            idString: *const ::std::os::raw::c_char,
            pInterfaceHandle: *mut VmbHandle_t,
        ) -> VmbError_t,
        ::libloading::Error,
    >,
    pub VmbInterfaceClose: Result<
        unsafe extern "C" fn(interfaceHandle: VmbHandle_t) -> VmbError_t,
        ::libloading::Error,
    >,
    pub VmbAncillaryDataOpen: Result<
        unsafe extern "C" fn(
            pFrame: *mut VmbFrame_t,
            pAncillaryDataHandle: *mut VmbHandle_t,
        ) -> VmbError_t,
        ::libloading::Error,
    >,
    pub VmbAncillaryDataClose: Result<
        unsafe extern "C" fn(ancillaryDataHandle: VmbHandle_t) -> VmbError_t,
        ::libloading::Error,
    >,
    pub VmbMemoryRead: Result<
        unsafe extern "C" fn(
            handle: VmbHandle_t,
            address: VmbUint64_t,
            bufferSize: VmbUint32_t,
            dataBuffer: *mut ::std::os::raw::c_char,
            pSizeComplete: *mut VmbUint32_t,
        ) -> VmbError_t,
        ::libloading::Error,
    >,
    pub VmbMemoryWrite: Result<
        unsafe extern "C" fn(
            handle: VmbHandle_t,
            address: VmbUint64_t,
            bufferSize: VmbUint32_t,
            dataBuffer: *const ::std::os::raw::c_char,
            pSizeComplete: *mut VmbUint32_t,
        ) -> VmbError_t,
        ::libloading::Error,
    >,
    pub VmbRegistersRead: Result<
        unsafe extern "C" fn(
            handle: VmbHandle_t,
            readCount: VmbUint32_t,
            pAddressArray: *const VmbUint64_t,
            pDataArray: *mut VmbUint64_t,
            pNumCompleteReads: *mut VmbUint32_t,
        ) -> VmbError_t,
        ::libloading::Error,
    >,
    pub VmbRegistersWrite: Result<
        unsafe extern "C" fn(
            handle: VmbHandle_t,
            writeCount: VmbUint32_t,
            pAddressArray: *const VmbUint64_t,
            pDataArray: *const VmbUint64_t,
            pNumCompleteWrites: *mut VmbUint32_t,
        ) -> VmbError_t,
        ::libloading::Error,
    >,
    pub VmbCameraSettingsSave: Result<
        unsafe extern "C" fn(
            handle: VmbHandle_t,
            fileName: *const ::std::os::raw::c_char,
            pSettings: *mut VmbFeaturePersistSettings_t,
            sizeofSettings: VmbUint32_t,
        ) -> VmbError_t,
        ::libloading::Error,
    >,
    pub VmbCameraSettingsLoad: Result<
        unsafe extern "C" fn(
            handle: VmbHandle_t,
            fileName: *const ::std::os::raw::c_char,
            pSettings: *mut VmbFeaturePersistSettings_t,
            sizeofSettings: VmbUint32_t,
        ) -> VmbError_t,
        ::libloading::Error,
    >,
}
impl VimbaC {
    pub unsafe fn new<P>(path: P) -> Result<Self, ::libloading::Error>
    where
        P: AsRef<::std::ffi::OsStr>,
    {
        let library = ::libloading::Library::new(path)?;
        Self::from_library(library)
    }
    pub unsafe fn from_library<L>(library: L) -> Result<Self, ::libloading::Error>
    where
        L: Into<::libloading::Library>,
    {
        let __library = library.into();
        let VmbVersionQuery = __library.get(b"VmbVersionQuery\0").map(|sym| *sym);
        let VmbStartup = __library.get(b"VmbStartup\0").map(|sym| *sym);
        let VmbShutdown = __library.get(b"VmbShutdown\0").map(|sym| *sym);
        let VmbCamerasList = __library.get(b"VmbCamerasList\0").map(|sym| *sym);
        let VmbCameraInfoQuery = __library.get(b"VmbCameraInfoQuery\0").map(|sym| *sym);
        let VmbCameraOpen = __library.get(b"VmbCameraOpen\0").map(|sym| *sym);
        let VmbCameraClose = __library.get(b"VmbCameraClose\0").map(|sym| *sym);
        let VmbFeaturesList = __library.get(b"VmbFeaturesList\0").map(|sym| *sym);
        let VmbFeatureInfoQuery = __library.get(b"VmbFeatureInfoQuery\0").map(|sym| *sym);
        let VmbFeatureListAffected = __library.get(b"VmbFeatureListAffected\0").map(|sym| *sym);
        let VmbFeatureListSelected = __library.get(b"VmbFeatureListSelected\0").map(|sym| *sym);
        let VmbFeatureAccessQuery = __library.get(b"VmbFeatureAccessQuery\0").map(|sym| *sym);
        let VmbFeatureIntGet = __library.get(b"VmbFeatureIntGet\0").map(|sym| *sym);
        let VmbFeatureIntSet = __library.get(b"VmbFeatureIntSet\0").map(|sym| *sym);
        let VmbFeatureIntRangeQuery = __library.get(b"VmbFeatureIntRangeQuery\0").map(|sym| *sym);
        let VmbFeatureIntIncrementQuery = __library
            .get(b"VmbFeatureIntIncrementQuery\0")
            .map(|sym| *sym);
        let VmbFeatureFloatGet = __library.get(b"VmbFeatureFloatGet\0").map(|sym| *sym);
        let VmbFeatureFloatSet = __library.get(b"VmbFeatureFloatSet\0").map(|sym| *sym);
        let VmbFeatureFloatRangeQuery = __library
            .get(b"VmbFeatureFloatRangeQuery\0")
            .map(|sym| *sym);
        let VmbFeatureFloatIncrementQuery = __library
            .get(b"VmbFeatureFloatIncrementQuery\0")
            .map(|sym| *sym);
        let VmbFeatureEnumGet = __library.get(b"VmbFeatureEnumGet\0").map(|sym| *sym);
        let VmbFeatureEnumSet = __library.get(b"VmbFeatureEnumSet\0").map(|sym| *sym);
        let VmbFeatureEnumRangeQuery = __library.get(b"VmbFeatureEnumRangeQuery\0").map(|sym| *sym);
        let VmbFeatureEnumIsAvailable = __library
            .get(b"VmbFeatureEnumIsAvailable\0")
            .map(|sym| *sym);
        let VmbFeatureEnumAsInt = __library.get(b"VmbFeatureEnumAsInt\0").map(|sym| *sym);
        let VmbFeatureEnumAsString = __library.get(b"VmbFeatureEnumAsString\0").map(|sym| *sym);
        let VmbFeatureEnumEntryGet = __library.get(b"VmbFeatureEnumEntryGet\0").map(|sym| *sym);
        let VmbFeatureStringGet = __library.get(b"VmbFeatureStringGet\0").map(|sym| *sym);
        let VmbFeatureStringSet = __library.get(b"VmbFeatureStringSet\0").map(|sym| *sym);
        let VmbFeatureStringMaxlengthQuery = __library
            .get(b"VmbFeatureStringMaxlengthQuery\0")
            .map(|sym| *sym);
        let VmbFeatureBoolGet = __library.get(b"VmbFeatureBoolGet\0").map(|sym| *sym);
        let VmbFeatureBoolSet = __library.get(b"VmbFeatureBoolSet\0").map(|sym| *sym);
        let VmbFeatureCommandRun = __library.get(b"VmbFeatureCommandRun\0").map(|sym| *sym);
        let VmbFeatureCommandIsDone = __library.get(b"VmbFeatureCommandIsDone\0").map(|sym| *sym);
        let VmbFeatureRawGet = __library.get(b"VmbFeatureRawGet\0").map(|sym| *sym);
        let VmbFeatureRawSet = __library.get(b"VmbFeatureRawSet\0").map(|sym| *sym);
        let VmbFeatureRawLengthQuery = __library.get(b"VmbFeatureRawLengthQuery\0").map(|sym| *sym);
        let VmbFeatureInvalidationRegister = __library
            .get(b"VmbFeatureInvalidationRegister\0")
            .map(|sym| *sym);
        let VmbFeatureInvalidationUnregister = __library
            .get(b"VmbFeatureInvalidationUnregister\0")
            .map(|sym| *sym);
        let VmbFrameAnnounce = __library.get(b"VmbFrameAnnounce\0").map(|sym| *sym);
        let VmbFrameRevoke = __library.get(b"VmbFrameRevoke\0").map(|sym| *sym);
        let VmbFrameRevokeAll = __library.get(b"VmbFrameRevokeAll\0").map(|sym| *sym);
        let VmbCaptureStart = __library.get(b"VmbCaptureStart\0").map(|sym| *sym);
        let VmbCaptureEnd = __library.get(b"VmbCaptureEnd\0").map(|sym| *sym);
        let VmbCaptureFrameQueue = __library.get(b"VmbCaptureFrameQueue\0").map(|sym| *sym);
        let VmbCaptureFrameWait = __library.get(b"VmbCaptureFrameWait\0").map(|sym| *sym);
        let VmbCaptureQueueFlush = __library.get(b"VmbCaptureQueueFlush\0").map(|sym| *sym);
        let VmbInterfacesList = __library.get(b"VmbInterfacesList\0").map(|sym| *sym);
        let VmbInterfaceOpen = __library.get(b"VmbInterfaceOpen\0").map(|sym| *sym);
        let VmbInterfaceClose = __library.get(b"VmbInterfaceClose\0").map(|sym| *sym);
        let VmbAncillaryDataOpen = __library.get(b"VmbAncillaryDataOpen\0").map(|sym| *sym);
        let VmbAncillaryDataClose = __library.get(b"VmbAncillaryDataClose\0").map(|sym| *sym);
        let VmbMemoryRead = __library.get(b"VmbMemoryRead\0").map(|sym| *sym);
        let VmbMemoryWrite = __library.get(b"VmbMemoryWrite\0").map(|sym| *sym);
        let VmbRegistersRead = __library.get(b"VmbRegistersRead\0").map(|sym| *sym);
        let VmbRegistersWrite = __library.get(b"VmbRegistersWrite\0").map(|sym| *sym);
        let VmbCameraSettingsSave = __library.get(b"VmbCameraSettingsSave\0").map(|sym| *sym);
        let VmbCameraSettingsLoad = __library.get(b"VmbCameraSettingsLoad\0").map(|sym| *sym);
        Ok(VimbaC {
            __library,
            VmbVersionQuery,
            VmbStartup,
            VmbShutdown,
            VmbCamerasList,
            VmbCameraInfoQuery,
            VmbCameraOpen,
            VmbCameraClose,
            VmbFeaturesList,
            VmbFeatureInfoQuery,
            VmbFeatureListAffected,
            VmbFeatureListSelected,
            VmbFeatureAccessQuery,
            VmbFeatureIntGet,
            VmbFeatureIntSet,
            VmbFeatureIntRangeQuery,
            VmbFeatureIntIncrementQuery,
            VmbFeatureFloatGet,
            VmbFeatureFloatSet,
            VmbFeatureFloatRangeQuery,
            VmbFeatureFloatIncrementQuery,
            VmbFeatureEnumGet,
            VmbFeatureEnumSet,
            VmbFeatureEnumRangeQuery,
            VmbFeatureEnumIsAvailable,
            VmbFeatureEnumAsInt,
            VmbFeatureEnumAsString,
            VmbFeatureEnumEntryGet,
            VmbFeatureStringGet,
            VmbFeatureStringSet,
            VmbFeatureStringMaxlengthQuery,
            VmbFeatureBoolGet,
            VmbFeatureBoolSet,
            VmbFeatureCommandRun,
            VmbFeatureCommandIsDone,
            VmbFeatureRawGet,
            VmbFeatureRawSet,
            VmbFeatureRawLengthQuery,
            VmbFeatureInvalidationRegister,
            VmbFeatureInvalidationUnregister,
            VmbFrameAnnounce,
            VmbFrameRevoke,
            VmbFrameRevokeAll,
            VmbCaptureStart,
            VmbCaptureEnd,
            VmbCaptureFrameQueue,
            VmbCaptureFrameWait,
            VmbCaptureQueueFlush,
            VmbInterfacesList,
            VmbInterfaceOpen,
            VmbInterfaceClose,
            VmbAncillaryDataOpen,
            VmbAncillaryDataClose,
            VmbMemoryRead,
            VmbMemoryWrite,
            VmbRegistersRead,
            VmbRegistersWrite,
            VmbCameraSettingsSave,
            VmbCameraSettingsLoad,
        })
    }
    pub unsafe fn VmbVersionQuery(
        &self,
        pVersionInfo: *mut VmbVersionInfo_t,
        sizeofVersionInfo: VmbUint32_t,
    ) -> VmbError_t {
        (self
            .VmbVersionQuery
            .as_ref()
            .expect("Expected function, got error."))(pVersionInfo, sizeofVersionInfo)
    }
    pub unsafe fn VmbStartup(&self) -> VmbError_t {
        (self
            .VmbStartup
            .as_ref()
            .expect("Expected function, got error."))()
    }
    pub unsafe fn VmbShutdown(&self) -> () {
        (self
            .VmbShutdown
            .as_ref()
            .expect("Expected function, got error."))()
    }
    pub unsafe fn VmbCamerasList(
        &self,
        pCameraInfo: *mut VmbCameraInfo_t,
        listLength: VmbUint32_t,
        pNumFound: *mut VmbUint32_t,
        sizeofCameraInfo: VmbUint32_t,
    ) -> VmbError_t {
        (self
            .VmbCamerasList
            .as_ref()
            .expect("Expected function, got error."))(
            pCameraInfo,
            listLength,
            pNumFound,
            sizeofCameraInfo,
        )
    }
    pub unsafe fn VmbCameraInfoQuery(
        &self,
        idString: *const ::std::os::raw::c_char,
        pInfo: *mut VmbCameraInfo_t,
        sizeofCameraInfo: VmbUint32_t,
    ) -> VmbError_t {
        (self
            .VmbCameraInfoQuery
            .as_ref()
            .expect("Expected function, got error."))(idString, pInfo, sizeofCameraInfo)
    }
    pub unsafe fn VmbCameraOpen(
        &self,
        idString: *const ::std::os::raw::c_char,
        accessMode: VmbAccessMode_t,
        pCameraHandle: *mut VmbHandle_t,
    ) -> VmbError_t {
        (self
            .VmbCameraOpen
            .as_ref()
            .expect("Expected function, got error."))(idString, accessMode, pCameraHandle)
    }
    pub unsafe fn VmbCameraClose(&self, cameraHandle: VmbHandle_t) -> VmbError_t {
        (self
            .VmbCameraClose
            .as_ref()
            .expect("Expected function, got error."))(cameraHandle)
    }
    pub unsafe fn VmbFeaturesList(
        &self,
        handle: VmbHandle_t,
        pFeatureInfoList: *mut VmbFeatureInfo_t,
        listLength: VmbUint32_t,
        pNumFound: *mut VmbUint32_t,
        sizeofFeatureInfo: VmbUint32_t,
    ) -> VmbError_t {
        (self
            .VmbFeaturesList
            .as_ref()
            .expect("Expected function, got error."))(
            handle,
            pFeatureInfoList,
            listLength,
            pNumFound,
            sizeofFeatureInfo,
        )
    }
    pub unsafe fn VmbFeatureInfoQuery(
        &self,
        handle: VmbHandle_t,
        name: *const ::std::os::raw::c_char,
        pFeatureInfo: *mut VmbFeatureInfo_t,
        sizeofFeatureInfo: VmbUint32_t,
    ) -> VmbError_t {
        (self
            .VmbFeatureInfoQuery
            .as_ref()
            .expect("Expected function, got error."))(
            handle, name, pFeatureInfo, sizeofFeatureInfo
        )
    }
    pub unsafe fn VmbFeatureListAffected(
        &self,
        handle: VmbHandle_t,
        name: *const ::std::os::raw::c_char,
        pFeatureInfoList: *mut VmbFeatureInfo_t,
        listLength: VmbUint32_t,
        pNumFound: *mut VmbUint32_t,
        sizeofFeatureInfo: VmbUint32_t,
    ) -> VmbError_t {
        (self
            .VmbFeatureListAffected
            .as_ref()
            .expect("Expected function, got error."))(
            handle,
            name,
            pFeatureInfoList,
            listLength,
            pNumFound,
            sizeofFeatureInfo,
        )
    }
    pub unsafe fn VmbFeatureListSelected(
        &self,
        handle: VmbHandle_t,
        name: *const ::std::os::raw::c_char,
        pFeatureInfoList: *mut VmbFeatureInfo_t,
        listLength: VmbUint32_t,
        pNumFound: *mut VmbUint32_t,
        sizeofFeatureInfo: VmbUint32_t,
    ) -> VmbError_t {
        (self
            .VmbFeatureListSelected
            .as_ref()
            .expect("Expected function, got error."))(
            handle,
            name,
            pFeatureInfoList,
            listLength,
            pNumFound,
            sizeofFeatureInfo,
        )
    }
    pub unsafe fn VmbFeatureAccessQuery(
        &self,
        handle: VmbHandle_t,
        name: *const ::std::os::raw::c_char,
        pIsReadable: *mut VmbBool_t,
        pIsWriteable: *mut VmbBool_t,
    ) -> VmbError_t {
        (self
            .VmbFeatureAccessQuery
            .as_ref()
            .expect("Expected function, got error."))(
            handle, name, pIsReadable, pIsWriteable
        )
    }
    pub unsafe fn VmbFeatureIntGet(
        &self,
        handle: VmbHandle_t,
        name: *const ::std::os::raw::c_char,
        pValue: *mut VmbInt64_t,
    ) -> VmbError_t {
        (self
            .VmbFeatureIntGet
            .as_ref()
            .expect("Expected function, got error."))(handle, name, pValue)
    }
    pub unsafe fn VmbFeatureIntSet(
        &self,
        handle: VmbHandle_t,
        name: *const ::std::os::raw::c_char,
        value: VmbInt64_t,
    ) -> VmbError_t {
        (self
            .VmbFeatureIntSet
            .as_ref()
            .expect("Expected function, got error."))(handle, name, value)
    }
    pub unsafe fn VmbFeatureIntRangeQuery(
        &self,
        handle: VmbHandle_t,
        name: *const ::std::os::raw::c_char,
        pMin: *mut VmbInt64_t,
        pMax: *mut VmbInt64_t,
    ) -> VmbError_t {
        (self
            .VmbFeatureIntRangeQuery
            .as_ref()
            .expect("Expected function, got error."))(handle, name, pMin, pMax)
    }
    pub unsafe fn VmbFeatureIntIncrementQuery(
        &self,
        handle: VmbHandle_t,
        name: *const ::std::os::raw::c_char,
        pValue: *mut VmbInt64_t,
    ) -> VmbError_t {
        (self
            .VmbFeatureIntIncrementQuery
            .as_ref()
            .expect("Expected function, got error."))(handle, name, pValue)
    }
    pub unsafe fn VmbFeatureFloatGet(
        &self,
        handle: VmbHandle_t,
        name: *const ::std::os::raw::c_char,
        pValue: *mut f64,
    ) -> VmbError_t {
        (self
            .VmbFeatureFloatGet
            .as_ref()
            .expect("Expected function, got error."))(handle, name, pValue)
    }
    pub unsafe fn VmbFeatureFloatSet(
        &self,
        handle: VmbHandle_t,
        name: *const ::std::os::raw::c_char,
        value: f64,
    ) -> VmbError_t {
        (self
            .VmbFeatureFloatSet
            .as_ref()
            .expect("Expected function, got error."))(handle, name, value)
    }
    pub unsafe fn VmbFeatureFloatRangeQuery(
        &self,
        handle: VmbHandle_t,
        name: *const ::std::os::raw::c_char,
        pMin: *mut f64,
        pMax: *mut f64,
    ) -> VmbError_t {
        (self
            .VmbFeatureFloatRangeQuery
            .as_ref()
            .expect("Expected function, got error."))(handle, name, pMin, pMax)
    }
    pub unsafe fn VmbFeatureFloatIncrementQuery(
        &self,
        handle: VmbHandle_t,
        name: *const ::std::os::raw::c_char,
        pHasIncrement: *mut VmbBool_t,
        pValue: *mut f64,
    ) -> VmbError_t {
        (self
            .VmbFeatureFloatIncrementQuery
            .as_ref()
            .expect("Expected function, got error."))(handle, name, pHasIncrement, pValue)
    }
    pub unsafe fn VmbFeatureEnumGet(
        &self,
        handle: VmbHandle_t,
        name: *const ::std::os::raw::c_char,
        pValue: *mut *const ::std::os::raw::c_char,
    ) -> VmbError_t {
        (self
            .VmbFeatureEnumGet
            .as_ref()
            .expect("Expected function, got error."))(handle, name, pValue)
    }
    pub unsafe fn VmbFeatureEnumSet(
        &self,
        handle: VmbHandle_t,
        name: *const ::std::os::raw::c_char,
        value: *const ::std::os::raw::c_char,
    ) -> VmbError_t {
        (self
            .VmbFeatureEnumSet
            .as_ref()
            .expect("Expected function, got error."))(handle, name, value)
    }
    pub unsafe fn VmbFeatureEnumRangeQuery(
        &self,
        handle: VmbHandle_t,
        name: *const ::std::os::raw::c_char,
        pNameArray: *mut *const ::std::os::raw::c_char,
        arrayLength: VmbUint32_t,
        pNumFilled: *mut VmbUint32_t,
    ) -> VmbError_t {
        (self
            .VmbFeatureEnumRangeQuery
            .as_ref()
            .expect("Expected function, got error."))(
            handle,
            name,
            pNameArray,
            arrayLength,
            pNumFilled,
        )
    }
    pub unsafe fn VmbFeatureEnumIsAvailable(
        &self,
        handle: VmbHandle_t,
        name: *const ::std::os::raw::c_char,
        value: *const ::std::os::raw::c_char,
        pIsAvailable: *mut VmbBool_t,
    ) -> VmbError_t {
        (self
            .VmbFeatureEnumIsAvailable
            .as_ref()
            .expect("Expected function, got error."))(handle, name, value, pIsAvailable)
    }
    pub unsafe fn VmbFeatureEnumAsInt(
        &self,
        handle: VmbHandle_t,
        name: *const ::std::os::raw::c_char,
        value: *const ::std::os::raw::c_char,
        pIntVal: *mut VmbInt64_t,
    ) -> VmbError_t {
        (self
            .VmbFeatureEnumAsInt
            .as_ref()
            .expect("Expected function, got error."))(handle, name, value, pIntVal)
    }
    pub unsafe fn VmbFeatureEnumAsString(
        &self,
        handle: VmbHandle_t,
        name: *const ::std::os::raw::c_char,
        intValue: VmbInt64_t,
        pStringValue: *mut *const ::std::os::raw::c_char,
    ) -> VmbError_t {
        (self
            .VmbFeatureEnumAsString
            .as_ref()
            .expect("Expected function, got error."))(handle, name, intValue, pStringValue)
    }
    pub unsafe fn VmbFeatureEnumEntryGet(
        &self,
        handle: VmbHandle_t,
        featureName: *const ::std::os::raw::c_char,
        entryName: *const ::std::os::raw::c_char,
        pFeatureEnumEntry: *mut VmbFeatureEnumEntry_t,
        sizeofFeatureEnumEntry: VmbUint32_t,
    ) -> VmbError_t {
        (self
            .VmbFeatureEnumEntryGet
            .as_ref()
            .expect("Expected function, got error."))(
            handle,
            featureName,
            entryName,
            pFeatureEnumEntry,
            sizeofFeatureEnumEntry,
        )
    }
    pub unsafe fn VmbFeatureStringGet(
        &self,
        handle: VmbHandle_t,
        name: *const ::std::os::raw::c_char,
        buffer: *mut ::std::os::raw::c_char,
        bufferSize: VmbUint32_t,
        pSizeFilled: *mut VmbUint32_t,
    ) -> VmbError_t {
        (self
            .VmbFeatureStringGet
            .as_ref()
            .expect("Expected function, got error."))(
            handle, name, buffer, bufferSize, pSizeFilled
        )
    }
    pub unsafe fn VmbFeatureStringSet(
        &self,
        handle: VmbHandle_t,
        name: *const ::std::os::raw::c_char,
        value: *const ::std::os::raw::c_char,
    ) -> VmbError_t {
        (self
            .VmbFeatureStringSet
            .as_ref()
            .expect("Expected function, got error."))(handle, name, value)
    }
    pub unsafe fn VmbFeatureStringMaxlengthQuery(
        &self,
        handle: VmbHandle_t,
        name: *const ::std::os::raw::c_char,
        pMaxLength: *mut VmbUint32_t,
    ) -> VmbError_t {
        (self
            .VmbFeatureStringMaxlengthQuery
            .as_ref()
            .expect("Expected function, got error."))(handle, name, pMaxLength)
    }
    pub unsafe fn VmbFeatureBoolGet(
        &self,
        handle: VmbHandle_t,
        name: *const ::std::os::raw::c_char,
        pValue: *mut VmbBool_t,
    ) -> VmbError_t {
        (self
            .VmbFeatureBoolGet
            .as_ref()
            .expect("Expected function, got error."))(handle, name, pValue)
    }
    pub unsafe fn VmbFeatureBoolSet(
        &self,
        handle: VmbHandle_t,
        name: *const ::std::os::raw::c_char,
        value: VmbBool_t,
    ) -> VmbError_t {
        (self
            .VmbFeatureBoolSet
            .as_ref()
            .expect("Expected function, got error."))(handle, name, value)
    }
    pub unsafe fn VmbFeatureCommandRun(
        &self,
        handle: VmbHandle_t,
        name: *const ::std::os::raw::c_char,
    ) -> VmbError_t {
        (self
            .VmbFeatureCommandRun
            .as_ref()
            .expect("Expected function, got error."))(handle, name)
    }
    pub unsafe fn VmbFeatureCommandIsDone(
        &self,
        handle: VmbHandle_t,
        name: *const ::std::os::raw::c_char,
        pIsDone: *mut VmbBool_t,
    ) -> VmbError_t {
        (self
            .VmbFeatureCommandIsDone
            .as_ref()
            .expect("Expected function, got error."))(handle, name, pIsDone)
    }
    pub unsafe fn VmbFeatureRawGet(
        &self,
        handle: VmbHandle_t,
        name: *const ::std::os::raw::c_char,
        pBuffer: *mut ::std::os::raw::c_char,
        bufferSize: VmbUint32_t,
        pSizeFilled: *mut VmbUint32_t,
    ) -> VmbError_t {
        (self
            .VmbFeatureRawGet
            .as_ref()
            .expect("Expected function, got error."))(
            handle,
            name,
            pBuffer,
            bufferSize,
            pSizeFilled,
        )
    }
    pub unsafe fn VmbFeatureRawSet(
        &self,
        handle: VmbHandle_t,
        name: *const ::std::os::raw::c_char,
        pBuffer: *const ::std::os::raw::c_char,
        bufferSize: VmbUint32_t,
    ) -> VmbError_t {
        (self
            .VmbFeatureRawSet
            .as_ref()
            .expect("Expected function, got error."))(handle, name, pBuffer, bufferSize)
    }
    pub unsafe fn VmbFeatureRawLengthQuery(
        &self,
        handle: VmbHandle_t,
        name: *const ::std::os::raw::c_char,
        pLength: *mut VmbUint32_t,
    ) -> VmbError_t {
        (self
            .VmbFeatureRawLengthQuery
            .as_ref()
            .expect("Expected function, got error."))(handle, name, pLength)
    }
    pub unsafe fn VmbFeatureInvalidationRegister(
        &self,
        handle: VmbHandle_t,
        name: *const ::std::os::raw::c_char,
        callback: VmbInvalidationCallback,
        pUserContext: *mut ::std::os::raw::c_void,
    ) -> VmbError_t {
        (self
            .VmbFeatureInvalidationRegister
            .as_ref()
            .expect("Expected function, got error."))(handle, name, callback, pUserContext)
    }
    pub unsafe fn VmbFeatureInvalidationUnregister(
        &self,
        handle: VmbHandle_t,
        name: *const ::std::os::raw::c_char,
        callback: VmbInvalidationCallback,
    ) -> VmbError_t {
        (self
            .VmbFeatureInvalidationUnregister
            .as_ref()
            .expect("Expected function, got error."))(handle, name, callback)
    }
    pub unsafe fn VmbFrameAnnounce(
        &self,
        cameraHandle: VmbHandle_t,
        pFrame: *const VmbFrame_t,
        sizeofFrame: VmbUint32_t,
    ) -> VmbError_t {
        (self
            .VmbFrameAnnounce
            .as_ref()
            .expect("Expected function, got error."))(cameraHandle, pFrame, sizeofFrame)
    }
    pub unsafe fn VmbFrameRevoke(
        &self,
        cameraHandle: VmbHandle_t,
        pFrame: *const VmbFrame_t,
    ) -> VmbError_t {
        (self
            .VmbFrameRevoke
            .as_ref()
            .expect("Expected function, got error."))(cameraHandle, pFrame)
    }
    pub unsafe fn VmbFrameRevokeAll(&self, cameraHandle: VmbHandle_t) -> VmbError_t {
        (self
            .VmbFrameRevokeAll
            .as_ref()
            .expect("Expected function, got error."))(cameraHandle)
    }
    pub unsafe fn VmbCaptureStart(&self, cameraHandle: VmbHandle_t) -> VmbError_t {
        (self
            .VmbCaptureStart
            .as_ref()
            .expect("Expected function, got error."))(cameraHandle)
    }
    pub unsafe fn VmbCaptureEnd(&self, cameraHandle: VmbHandle_t) -> VmbError_t {
        (self
            .VmbCaptureEnd
            .as_ref()
            .expect("Expected function, got error."))(cameraHandle)
    }
    pub unsafe fn VmbCaptureFrameQueue(
        &self,
        cameraHandle: VmbHandle_t,
        pFrame: *const VmbFrame_t,
        callback: VmbFrameCallback,
    ) -> VmbError_t {
        (self
            .VmbCaptureFrameQueue
            .as_ref()
            .expect("Expected function, got error."))(cameraHandle, pFrame, callback)
    }
    pub unsafe fn VmbCaptureFrameWait(
        &self,
        cameraHandle: VmbHandle_t,
        pFrame: *const VmbFrame_t,
        timeout: VmbUint32_t,
    ) -> VmbError_t {
        (self
            .VmbCaptureFrameWait
            .as_ref()
            .expect("Expected function, got error."))(cameraHandle, pFrame, timeout)
    }
    pub unsafe fn VmbCaptureQueueFlush(&self, cameraHandle: VmbHandle_t) -> VmbError_t {
        (self
            .VmbCaptureQueueFlush
            .as_ref()
            .expect("Expected function, got error."))(cameraHandle)
    }
    pub unsafe fn VmbInterfacesList(
        &self,
        pInterfaceInfo: *mut VmbInterfaceInfo_t,
        listLength: VmbUint32_t,
        pNumFound: *mut VmbUint32_t,
        sizeofInterfaceInfo: VmbUint32_t,
    ) -> VmbError_t {
        (self
            .VmbInterfacesList
            .as_ref()
            .expect("Expected function, got error."))(
            pInterfaceInfo,
            listLength,
            pNumFound,
            sizeofInterfaceInfo,
        )
    }
    pub unsafe fn VmbInterfaceOpen(
        &self,
        idString: *const ::std::os::raw::c_char,
        pInterfaceHandle: *mut VmbHandle_t,
    ) -> VmbError_t {
        (self
            .VmbInterfaceOpen
            .as_ref()
            .expect("Expected function, got error."))(idString, pInterfaceHandle)
    }
    pub unsafe fn VmbInterfaceClose(&self, interfaceHandle: VmbHandle_t) -> VmbError_t {
        (self
            .VmbInterfaceClose
            .as_ref()
            .expect("Expected function, got error."))(interfaceHandle)
    }
    pub unsafe fn VmbAncillaryDataOpen(
        &self,
        pFrame: *mut VmbFrame_t,
        pAncillaryDataHandle: *mut VmbHandle_t,
    ) -> VmbError_t {
        (self
            .VmbAncillaryDataOpen
            .as_ref()
            .expect("Expected function, got error."))(pFrame, pAncillaryDataHandle)
    }
    pub unsafe fn VmbAncillaryDataClose(&self, ancillaryDataHandle: VmbHandle_t) -> VmbError_t {
        (self
            .VmbAncillaryDataClose
            .as_ref()
            .expect("Expected function, got error."))(ancillaryDataHandle)
    }
    pub unsafe fn VmbMemoryRead(
        &self,
        handle: VmbHandle_t,
        address: VmbUint64_t,
        bufferSize: VmbUint32_t,
        dataBuffer: *mut ::std::os::raw::c_char,
        pSizeComplete: *mut VmbUint32_t,
    ) -> VmbError_t {
        (self
            .VmbMemoryRead
            .as_ref()
            .expect("Expected function, got error."))(
            handle,
            address,
            bufferSize,
            dataBuffer,
            pSizeComplete,
        )
    }
    pub unsafe fn VmbMemoryWrite(
        &self,
        handle: VmbHandle_t,
        address: VmbUint64_t,
        bufferSize: VmbUint32_t,
        dataBuffer: *const ::std::os::raw::c_char,
        pSizeComplete: *mut VmbUint32_t,
    ) -> VmbError_t {
        (self
            .VmbMemoryWrite
            .as_ref()
            .expect("Expected function, got error."))(
            handle,
            address,
            bufferSize,
            dataBuffer,
            pSizeComplete,
        )
    }
    pub unsafe fn VmbRegistersRead(
        &self,
        handle: VmbHandle_t,
        readCount: VmbUint32_t,
        pAddressArray: *const VmbUint64_t,
        pDataArray: *mut VmbUint64_t,
        pNumCompleteReads: *mut VmbUint32_t,
    ) -> VmbError_t {
        (self
            .VmbRegistersRead
            .as_ref()
            .expect("Expected function, got error."))(
            handle,
            readCount,
            pAddressArray,
            pDataArray,
            pNumCompleteReads,
        )
    }
    pub unsafe fn VmbRegistersWrite(
        &self,
        handle: VmbHandle_t,
        writeCount: VmbUint32_t,
        pAddressArray: *const VmbUint64_t,
        pDataArray: *const VmbUint64_t,
        pNumCompleteWrites: *mut VmbUint32_t,
    ) -> VmbError_t {
        (self
            .VmbRegistersWrite
            .as_ref()
            .expect("Expected function, got error."))(
            handle,
            writeCount,
            pAddressArray,
            pDataArray,
            pNumCompleteWrites,
        )
    }
    pub unsafe fn VmbCameraSettingsSave(
        &self,
        handle: VmbHandle_t,
        fileName: *const ::std::os::raw::c_char,
        pSettings: *mut VmbFeaturePersistSettings_t,
        sizeofSettings: VmbUint32_t,
    ) -> VmbError_t {
        (self
            .VmbCameraSettingsSave
            .as_ref()
            .expect("Expected function, got error."))(
            handle, fileName, pSettings, sizeofSettings
        )
    }
    pub unsafe fn VmbCameraSettingsLoad(
        &self,
        handle: VmbHandle_t,
        fileName: *const ::std::os::raw::c_char,
        pSettings: *mut VmbFeaturePersistSettings_t,
        sizeofSettings: VmbUint32_t,
    ) -> VmbError_t {
        (self
            .VmbCameraSettingsLoad
            .as_ref()
            .expect("Expected function, got error."))(
            handle, fileName, pSettings, sizeofSettings
        )
    }
}
